use futures_channel::mpsc::UnboundedSender;
use log::{debug, error};
use std::{
    collections::HashMap,
    time::{SystemTime, UNIX_EPOCH},
};
use thiserror::Error;

use crate::app::{App, MailboxMessage};
use magic_wormhole::message::{
    ClientMessage, NameplateInfo, PermissionMethod, Phase, ServerMessage, ServerMessageType,
    WelcomeInfo,
};

/// A client connected via WebSocket.
#[derive(Debug)]
pub(crate) struct Connection {
    /// A transmission channel for the connection.
    pub(crate) sender: UnboundedSender<ServerMessage>,
    /// Client's Application namespace.
    app_id: Option<String>,
    /// Client's ID string.
    side: Option<String>,
    /// The currently open mailbox.
    mailbox_id: Option<String>,
    /// The currently associated nameplate.
    nameplate_id: Option<usize>,
    /// Has the client been allocated a nameplate?
    allocated: bool,
    /// Has the client claimed a nameplate?
    claimed: bool,
    /// Has the client released a nameplate?
    released: bool,
}

impl Connection {
    /// Create a new connection with the associated transmission channel.
    pub(crate) fn new(sender: UnboundedSender<ServerMessage>) -> Self {
        Connection {
            sender,
            app_id: None,
            side: None,
            nameplate_id: None,
            mailbox_id: None,
            allocated: false,
            claimed: false,
            released: false,
        }
    }

    /// Has the client bound an application namespace and ID string?
    fn bound(&self) -> bool {
        self.app_id.is_some() && self.side.is_some()
    }

    /// Has the client been allocated a nameplate?
    fn allocated(&self) -> bool {
        self.allocated
    }

    /// Has the client claimed a nameplate?
    fn claimed(&self) -> bool {
        self.claimed
    }
}

/// Errors generated by the server.
#[derive(Error, Debug)]
pub(crate) enum ServerError {
    #[error("only one mailbox per connection")]
    MailboxAlreadyOpened,
    #[error("release must match claim")]
    ReleaseMustMatchClaim,
    #[error("no nameplate to release")]
    NoNameplateToRelease,
    #[error("already released")]
    AlreadyReleased,
    #[error("already claimed")]
    AlreadyClaimed,
    #[error("already bound")]
    AlreadyBound,
    #[error("must bind first")]
    NotBound,
    #[error("no open mailbox")]
    NoOpenMailbox,
    #[error("already allocated")]
    AlreadyAllocated,
    #[error("invalid mailbox")]
    InvalidMailbox,
    #[error("could not allocate nameplate")]
    CouldNotAllocate,
    #[error("nameplate is crowded")]
    CrowdedNameplate,
    #[error("failed to create or parse message")]
    SerdeJsonError(#[from] serde_json::Error),
    #[error("failed to send websocket message")]
    ChannelError(#[from] futures_channel::mpsc::TrySendError<ServerMessage>),
}

/// A mailbox server. Its connections and contents are separated into
/// application namespaces.
#[derive(Debug, Default)]
pub(crate) struct MailboxServer {
    apps: HashMap<String, App>,
}

impl MailboxServer {
    /// Connect a new client. Will send them the welcome message.
    pub(crate) fn connect(&self, conn: &Connection) -> Result<(), ServerError> {
        let welcome_msg = ServerMessage::new(
            None,
            None,
            ServerMessageType::Welcome {
                welcome: WelcomeInfo {
                    motd: None,
                    error: None,
                    permission_required: vec![PermissionMethod::None],
                },
            },
        );
        debug!("Sent {:?}", &welcome_msg.ty);
        conn.sender.unbounded_send(welcome_msg)?;
        Ok(())
    }

    /// Handle a client disconnection. Removes them from any nameplates or mailboxes.
    pub(crate) fn disconnect(&mut self, conn: &mut Connection) {
        if !conn.bound() {
            debug!("Unbound client disconnected");
            return;
        }
        let side = conn.side.as_ref().unwrap();
        debug!("Client {:?} disconnected", side);

        // Remove connection from any pending nameplates
        self.apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .remove_side_from_nameplates(side);

        // Remove connection from any open mailboxes
        self.apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .remove_subscriber_from_mailboxes(&conn.sender);
    }

    /// Send an Ack message in the response to the given message.
    pub(crate) fn ack(&self, conn: &Connection, msg: &ClientMessage) -> Result<(), ServerError> {
        let ack_msg = ServerMessage::ack(msg.id.clone());
        conn.sender.unbounded_send(ack_msg)?;
        debug!("Sent Ack for {:?}", &msg.ty);
        Ok(())
    }

    /// Handle a client bind.
    pub(crate) fn bind(
        &mut self,
        conn: &mut Connection,
        app_id: &str,
        side: &str,
    ) -> Result<(), ServerError> {
        if conn.bound() {
            return Err(ServerError::AlreadyBound);
        }
        self.apps.entry(app_id.to_owned()).or_insert_with(|| {
            debug!("Spawning app {:?}", app_id);
            App::default()
        });
        conn.app_id = Some(app_id.to_owned());
        conn.side = Some(side.to_owned());
        Ok(())
    }

    /// Handle a client request for the list of active nameplates.
    pub(crate) fn list(&self, conn: &Connection) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }

        let nameplates = self
            .apps
            .get(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .get_nameplates()
            .iter()
            .map(|n| NameplateInfo { id: *n })
            .collect::<Vec<NameplateInfo>>();
        let list_msg = ServerMessage::new(None, None, ServerMessageType::Nameplates { nameplates });
        debug!("Sent {:?}", &list_msg.ty);
        conn.sender.unbounded_send(list_msg)?;

        Ok(())
    }

    /// Handle a client request for nameplate allocation.
    pub(crate) fn allocate(&mut self, conn: &mut Connection) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }
        if conn.allocated() {
            return Err(ServerError::AlreadyAllocated);
        }

        conn.nameplate_id = match self
            .apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .allocate_nameplate(conn.side.as_ref().unwrap(), conn.sender.clone())
        {
            Some(nameplate_id) => Some(nameplate_id),
            None => return Err(ServerError::CouldNotAllocate),
        };
        conn.allocated = true;

        let allocated_msg = ServerMessage::new(
            None,
            None,
            ServerMessageType::Allocated {
                nameplate_id: *conn.nameplate_id.as_ref().unwrap(),
            },
        );
        debug!("Sent {:?}", &allocated_msg.ty);
        conn.sender.unbounded_send(allocated_msg)?;

        Ok(())
    }

    /// Handle a client request to claim a nameplate.
    pub(crate) fn claim(
        &mut self,
        conn: &mut Connection,
        nameplate_id: usize,
    ) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }
        if conn.claimed() {
            return Err(ServerError::AlreadyClaimed);
        }

        let mailbox_id = match self
            .apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .claim_nameplate(
                nameplate_id,
                conn.side.as_ref().unwrap(),
                conn.sender.clone(),
            ) {
            Some(mailbox_id) => mailbox_id,
            None => {
                return Err(ServerError::CrowdedNameplate);
            }
        };
        conn.nameplate_id = Some(nameplate_id);
        conn.claimed = true;

        let claimed_msg = ServerMessage::new(None, None, ServerMessageType::Claimed { mailbox_id });
        debug!("Sent {:?}", &claimed_msg.ty);
        conn.sender.unbounded_send(claimed_msg)?;

        Ok(())
    }

    /// Handle client request to release a nameplate it.
    pub(crate) fn release(
        &mut self,
        conn: &mut Connection,
        nameplate_id: Option<usize>,
    ) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }
        if conn.released {
            return Err(ServerError::AlreadyReleased);
        }
        if conn.nameplate_id.is_none() {
            return Err(ServerError::NoNameplateToRelease);
        }

        let nameplate_id = if let Some(nameplate_id) = nameplate_id {
            if conn.nameplate_id != Some(nameplate_id) {
                return Err(ServerError::ReleaseMustMatchClaim);
            }
            nameplate_id
        } else {
            *conn.nameplate_id.as_ref().unwrap()
        };

        self.apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .release_nameplate(nameplate_id, conn.side.as_ref().unwrap());
        conn.released = true;
        conn.nameplate_id = None;

        let released_msg = ServerMessage::new(None, None, ServerMessageType::Released);
        debug!("Sent {:?}", &released_msg.ty);
        conn.sender.unbounded_send(released_msg)?;

        Ok(())
    }

    /// Handle a client request to open (i.e., subscribe to) a mailbox. Any messages already
    /// in the mailbox will be forwarded to the client immediately.
    pub(crate) fn open(
        &mut self,
        conn: &mut Connection,
        mailbox_id: &str,
    ) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }
        if conn.mailbox_id.is_some() {
            return Err(ServerError::MailboxAlreadyOpened);
        }

        let app = self
            .apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app");
        if !app.mailboxes.contains_key(mailbox_id) {
            return Err(ServerError::InvalidMailbox);
        }
        app.open_mailbox(mailbox_id, conn.side.as_ref().unwrap(), conn.sender.clone());
        conn.mailbox_id = Some(mailbox_id.to_owned());

        Ok(())
    }

    /// Handle a client adding a new message to their open mailbox. Will forward the message
    /// immediately to all connected clients (including the sender themselves).
    pub(crate) fn add(
        &mut self,
        conn: &Connection,
        id: &str,
        phase: &Phase,
        body: &[u8],
    ) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }
        if conn.mailbox_id.is_none() {
            return Err(ServerError::NoOpenMailbox);
        }

        let mailbox_msg = MailboxMessage {
            id: id.to_owned(),
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs_f64(),
            side: conn.side.as_ref().unwrap().to_owned(),
            phase: phase.to_owned(),
            body: body.to_vec(),
        };
        self.apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app")
            .add_message_to_mailbox(conn.mailbox_id.as_ref().unwrap(), mailbox_msg);

        Ok(())
    }

    /// Handle client close request.
    pub(crate) fn close(&mut self, conn: &Connection, mailbox_id: &str) -> Result<(), ServerError> {
        if !conn.bound() {
            return Err(ServerError::NotBound);
        }

        let app = self
            .apps
            .get_mut(conn.app_id.as_ref().unwrap())
            .expect("non-existant app");
        if !app.mailboxes.contains_key(mailbox_id) {
            return Err(ServerError::InvalidMailbox);
        }
        app.close_mailbox(mailbox_id, conn.side.as_ref().unwrap());

        let closed_msg = ServerMessage::new(None, None, ServerMessageType::Closed);
        debug!("Sent {:?}", &closed_msg.ty);
        conn.sender.unbounded_send(closed_msg)?;

        // TODO: Log client's mood

        Ok(())
    }

    /// Respond to client ping.
    pub(crate) fn ping(
        &self,
        conn: &Connection,
        msg_id: &str,
        ping: u32,
    ) -> Result<(), ServerError> {
        let pong_msg = ServerMessage::new(
            Some(msg_id.to_owned()),
            None,
            ServerMessageType::Pong { ping },
        );
        debug!("Sent {:?}", &pong_msg.ty);
        conn.sender.unbounded_send(pong_msg)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    // use super::MailboxServer;

    // TODO: Tests for MailboxServer

    #[test]
    fn test() {
        // let mut server = MailboxServer::default();
    }
}
