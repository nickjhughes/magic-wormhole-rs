use futures_channel::mpsc::UnboundedSender;
use log::debug;
use rand::prelude::*;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use spake2::{Ed25519Group, Identity, Password, Spake2};
use std::collections::HashMap;
use thiserror::Error;
use tokio_tungstenite::tungstenite::Message;

use crate::crypto::{decrypt_message, encrypt_message};
use crate::words::choose_words;
use magic_wormhole::message::{ClientMessage, ClientMessageType, Mood, Phase};

/// A message sent between peers for the purpose of setting up their connection.
#[serde_as]
#[derive(Debug, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
enum PeerMessage {
    /// The initial PAKE message.
    Pake {
        #[serde_as(as = "serde_with::hex::Hex")]
        pake_v1: Vec<u8>,
    },
    /// Information about the sender.
    Version {
        #[serde(skip_serializing_if = "Option::is_none")]
        abilities: Option<Vec<String>>,
        app_versions: HashMap<String, String>,
    },
}

/// An application-specific message sent between clients.
#[derive(Debug, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
enum ApplicationMessage {
    /// An offer of a text message.
    Offer { message: String },
    /// A reception of a text message.
    Answer { message_ack: String },
}

/// A command for the client to execute.
#[derive(Debug, PartialEq)]
pub(crate) enum ClientCommand {
    /// Send the given text.
    Send { text: String },
    /// Receive using the given code.
    Receive { code: String },
}

/// State of the client.
#[derive(Debug, Default, PartialEq)]
enum ClientState {
    /// Initial state.
    #[default]
    Init,
    /// Sent bound message.
    Bound,
    /// Sent allocate message.
    Allocating,
    /// Sent claim message.
    Claiming,
    /// Sent PAKE message.
    Pake,
    /// Sent version message.
    Version,
    /// Connected to peer and successfully derived an encryption key,
    /// ready to communicate.
    Connected,
    /// Client is closing the mailbox.
    Closing,
    /// Mailbox is closed, client is done and ready to terminate the connection.
    Closed,
}

/// Errors generated by the client.
#[derive(Error, Debug)]
pub(crate) enum ClientError {
    #[error("failed to create or parse message")]
    SerdeJsonError(#[from] serde_json::Error),
    #[error("failed to send websocket message")]
    ChannelError(
        #[from] futures_channel::mpsc::TrySendError<tokio_tungstenite::tungstenite::Message>,
    ),
}

/// A wormhole client.
#[derive(Debug)]
pub(crate) struct Client {
    /// Application namespace.
    pub app_id: String,
    /// The client's ID string.
    pub side: String,
    /// The command the client is executing.
    pub command: ClientCommand,
    /// The client's current mood.
    mood: Mood,
    /// A transmission channel for sending messages to the server.
    sender: UnboundedSender<Message>,
    /// The client's current state.
    state: ClientState,
    /// The currently associated nameplate ID.
    nameplate_id: Option<usize>,
    /// The currently open mailbox ID.
    mailbox_id: Option<String>,
    /// PAKE algorithm.
    spake: Option<Spake2<Ed25519Group>>,
    /// The PAKE-derived key used for encryption, once computed.
    key: Option<Vec<u8>>,
}

impl Client {
    /// Create a new client and run the given command.
    pub(crate) fn new(
        command: ClientCommand,
        app_id: String,
        sender: UnboundedSender<Message>,
    ) -> Self {
        let side = Client::generate_side();
        Client {
            app_id,
            side,
            sender,
            command,
            mood: Mood::Lonely,
            state: ClientState::default(),
            nameplate_id: None,
            mailbox_id: None,
            spake: None,
            key: None,
        }
    }

    /// Is the client ready for the connection to be terminated?
    pub(crate) fn is_closed(&self) -> bool {
        self.state == ClientState::Closed
    }

    /// Send a bind message to the server.
    pub(crate) fn bind(&mut self) -> Result<(), ClientError> {
        assert_eq!(self.state, ClientState::Init);

        let bind_msg = ClientMessage::new(ClientMessageType::Bind {
            app_id: self.app_id.clone(),
            side: self.side.clone(),
        });
        self.sender
            .unbounded_send(Message::Text(serde_json::to_string(&bind_msg)?))?;
        debug!("Sent {:?}, {:?}", bind_msg.id, bind_msg.ty);
        self.state = ClientState::Bound;

        Ok(())
    }

    /// Request a nameplate from the server.
    pub(crate) fn allocate(&mut self) -> Result<(), ClientError> {
        assert_eq!(self.state, ClientState::Bound);

        self.state = ClientState::Allocating;
        let allocate_msg = ClientMessage::new(ClientMessageType::Allocate);
        self.sender
            .unbounded_send(Message::Text(serde_json::to_string(&allocate_msg)?))?;
        debug!("Sent {:?}, {:?}", allocate_msg.id, allocate_msg.ty);

        Ok(())
    }

    /// Handle a nameplate allocation from the server.
    pub(crate) fn allocated(&mut self, nameplate_id: usize) -> Result<(), ClientError> {
        assert_eq!(self.state, ClientState::Allocating);
        self.claim(Some(nameplate_id))
    }

    /// Request to claim a nameplate. If a `nameplate_id` is given, claim that one.
    /// Otherwise, assume we are receiving, and claim the nameplate derived from
    /// our code.
    pub(crate) fn claim(&mut self, nameplate_id: Option<usize>) -> Result<(), ClientError> {
        if let Some(nameplate_id) = nameplate_id {
            // Claim the given nameplate (from an allocation)
            assert_eq!(self.state, ClientState::Allocating);
            self.nameplate_id = Some(nameplate_id);
        } else {
            // Claim the nameplate from our receive command
            assert_eq!(self.state, ClientState::Bound);
            let nameplate_id = match &self.command {
                ClientCommand::Send { .. } => {
                    panic!("Invalid command");
                }
                ClientCommand::Receive { code } => {
                    let mut parts = code.split('-');
                    parts.next().unwrap().parse::<usize>().unwrap()
                }
            };
            self.nameplate_id = Some(nameplate_id);
        }

        self.state = ClientState::Claiming;
        let claim_msg = ClientMessage::new(ClientMessageType::Claim {
            nameplate_id: *self.nameplate_id.as_ref().unwrap(),
        });
        self.sender
            .unbounded_send(Message::Text(serde_json::to_string(&claim_msg)?))?;
        debug!("Sent {:?}, {:?}", claim_msg.id, claim_msg.ty);

        Ok(())
    }

    /// Handle a nameplate claim from the server. Will initiate the PAKE sequence to establish
    /// a shared encryption key with a peer.
    pub(crate) fn claimed(&mut self, mailbox_id: &str) -> Result<(), ClientError> {
        assert_eq!(self.state, ClientState::Claiming);

        self.mailbox_id = Some(mailbox_id.to_owned());
        let open_msg = ClientMessage::new(ClientMessageType::Open {
            mailbox_id: mailbox_id.to_owned(),
        });
        self.sender
            .unbounded_send(Message::Text(serde_json::to_string(&open_msg)?))?;
        debug!("Send {:?}, {:?}", open_msg.id, open_msg.ty);

        // Send first message
        self.state = ClientState::Pake;
        let code = match &self.command {
            ClientCommand::Send { .. } => {
                // Choose a random code
                let mut c = self.nameplate_id.unwrap().to_string();
                c.push('-');
                c.push_str(&choose_words(2));
                c
            }
            ClientCommand::Receive { code } => code.to_owned(),
        };

        let (spake, raw_msg) = Spake2::<Ed25519Group>::start_symmetric(
            &Password::new(code.clone()),
            &Identity::new(self.app_id.as_bytes()),
        );
        let body = serde_json::to_string(&PeerMessage::Pake { pake_v1: raw_msg })?;
        self.spake = Some(spake);
        let pake_msg = ClientMessage::new(ClientMessageType::Add {
            phase: Phase::Pake,
            body: body.as_bytes().to_vec(),
        });
        self.sender
            .unbounded_send(Message::Text(serde_json::to_string(&pake_msg)?))?;
        debug!("Sent {:?}, {:?}", pake_msg.id, pake_msg.ty);

        // TODO: We probably shouldn't print this until we've actually sent the message
        if matches!(self.command, ClientCommand::Send { .. }) {
            println!("Wormhole code is {}", code);
            println!("On the other computer, please run:");
            println!();
            println!("wormhole receive {}", code);
        }

        Ok(())
    }

    /// Release our nameplate.
    pub(crate) fn release(&mut self) -> Result<(), ClientError> {
        let release_msg = ClientMessage::new(ClientMessageType::Release {
            nameplate_id: Some(self.nameplate_id.take().unwrap()),
        });
        self.sender
            .unbounded_send(Message::Text(serde_json::to_string(&release_msg)?))?;
        debug!("Sent {:?}, {:?}", release_msg.id, release_msg.ty);

        Ok(())
    }

    /// Handle mailbox message reception.
    pub(crate) fn message(
        &mut self,
        side: &str,
        phase: &Phase,
        body: &[u8],
    ) -> Result<(), ClientError> {
        if side == self.side {
            // Just an echo of our own message
            return Ok(());
        }

        // If we haven't already, we can now relased the nameplate
        if self.nameplate_id.is_some() {
            self.release()?;
        }

        match self.state {
            ClientState::Pake => {
                assert_eq!(*phase, Phase::Pake);
                assert!(self.spake.is_some());
                let pake_msg = serde_json::from_slice::<PeerMessage>(body).unwrap();
                match pake_msg {
                    PeerMessage::Pake { pake_v1 } => {
                        self.key = Some(self.spake.take().unwrap().finish(&pake_v1).unwrap());
                        self.state = ClientState::Version;

                        let body = serde_json::to_string(&PeerMessage::Version {
                            abilities: None,
                            app_versions: HashMap::new(),
                        })?;
                        let encrypted_body = encrypt_message(
                            &body,
                            self.key.as_ref().unwrap(),
                            &self.side,
                            &Phase::Version,
                        );
                        let version_msg = ClientMessage::new(ClientMessageType::Add {
                            phase: Phase::Version,
                            body: encrypted_body,
                        });
                        self.sender
                            .unbounded_send(Message::Text(serde_json::to_string(&version_msg)?))?;
                        debug!("Sent {:?}, {:?}", version_msg.id, version_msg.ty);
                    }
                    _ => {
                        panic!("invalid message, expecting 'pake'")
                    }
                }
            }
            ClientState::Version => {
                assert_eq!(*phase, Phase::Version);
                let decrypted_body =
                    match decrypt_message(body, self.key.as_ref().unwrap(), side, phase) {
                        Ok(msg) => {
                            self.mood = Mood::Happy;
                            self.state = ClientState::Connected;
                            msg
                        }
                        Err(_) => {
                            println!("Decryption failed!");
                            self.mood = Mood::Scary;

                            let close_msg = ClientMessage::new(ClientMessageType::Close {
                                mailbox_id: self.mailbox_id.as_ref().unwrap().clone(),
                                mood: self.mood.clone(),
                            });
                            self.sender
                                .unbounded_send(Message::Text(serde_json::to_string(
                                    &close_msg,
                                )?))?;
                            debug!("Sent {:?}, {:?}", close_msg.id, close_msg.ty);
                            self.mailbox_id = None;

                            self.state = ClientState::Closing;

                            return Ok(());
                        }
                    };
                let version_msg = serde_json::from_str::<PeerMessage>(&decrypted_body).unwrap();
                match version_msg {
                    PeerMessage::Version { .. } => {
                        debug!("Got version message: {:?}", version_msg);

                        if let ClientCommand::Send { text } = &self.command {
                            let body = serde_json::to_string(&ApplicationMessage::Offer {
                                message: text.clone(),
                            })?;
                            let phase = Phase::Message(0);
                            let encrypted_body = encrypt_message(
                                &body,
                                self.key.as_ref().unwrap(),
                                &self.side,
                                &phase,
                            );
                            let msg = ClientMessage::new(ClientMessageType::Add {
                                phase,
                                body: encrypted_body,
                            });
                            self.sender
                                .unbounded_send(Message::Text(serde_json::to_string(&msg)?))?;
                            debug!("Sent {:?}, {:?}", msg.id, msg.ty);
                        }
                    }
                    _ => {
                        panic!("invalid message, expecting 'version'")
                    }
                }
            }
            ClientState::Connected => {
                // let phase_number = phase.parse::<usize>().expect("phase should be numerical");
                let phase_number = 0;
                debug!("Got message phase {}", phase_number);
                let decrypted_body =
                    match decrypt_message(body, self.key.as_ref().unwrap(), side, phase) {
                        Ok(msg) => msg,
                        Err(_) => {
                            println!("Decryption failed!");
                            self.mood = Mood::Scary;

                            let close_msg = ClientMessage::new(ClientMessageType::Close {
                                mailbox_id: self.mailbox_id.as_ref().unwrap().clone(),
                                mood: self.mood.clone(),
                            });
                            self.sender
                                .unbounded_send(Message::Text(serde_json::to_string(
                                    &close_msg,
                                )?))?;
                            debug!("Sent {:?}, {:?}", close_msg.id, close_msg.ty);
                            self.mailbox_id = None;

                            self.state = ClientState::Closing;

                            return Ok(());
                        }
                    };
                debug!("Decrypted message: {:?}", decrypted_body);
                let msg = serde_json::from_str::<ApplicationMessage>(&decrypted_body).unwrap();
                match msg {
                    ApplicationMessage::Offer { message } => {
                        // We've been send a message: display to user and reply with ack
                        println!("{}", message);

                        let body = serde_json::to_string(&ApplicationMessage::Answer {
                            message_ack: "ok".into(),
                        })?;
                        let phase = Phase::Message(0);
                        let encrypted_body =
                            encrypt_message(&body, self.key.as_ref().unwrap(), &self.side, &phase);
                        let ack_msg = ClientMessage::new(ClientMessageType::Add {
                            phase,
                            body: encrypted_body,
                        });
                        self.sender
                            .unbounded_send(Message::Text(serde_json::to_string(&ack_msg)?))?;
                        debug!("Sent {:?}, {:?}", ack_msg.id, ack_msg.ty);

                        let close_msg = ClientMessage::new(ClientMessageType::Close {
                            mailbox_id: self.mailbox_id.as_ref().unwrap().clone(),
                            mood: self.mood.clone(),
                        });
                        self.sender
                            .unbounded_send(Message::Text(serde_json::to_string(&close_msg)?))?;
                        debug!("Sent {:?}, {:?}", close_msg.id, close_msg.ty);
                        self.mailbox_id = None;

                        self.state = ClientState::Closing;
                    }
                    ApplicationMessage::Answer { message_ack } => {
                        if message_ack == "ok" {
                            // Our message has been ack'ed
                            println!("text message sent");
                        } else {
                            eprintln!("Something went wrong: {:?}", message_ack);
                        }

                        let close_msg = ClientMessage::new(ClientMessageType::Close {
                            mailbox_id: self.mailbox_id.as_ref().unwrap().clone(),
                            mood: self.mood.clone(),
                        });
                        self.sender
                            .unbounded_send(Message::Text(serde_json::to_string(&close_msg)?))?;
                        debug!("Sent {:?}, {:?}", close_msg.id, close_msg.ty);
                        self.mailbox_id = None;

                        self.state = ClientState::Closing;
                    }
                }
            }
            _ => panic!("invalid state"),
        }

        Ok(())
    }

    /// Handle confirmation of mailbox closure from server.
    pub(crate) fn closed(&mut self) {
        self.state = ClientState::Closed;
    }

    /// Generate a random 16-byte hex identifier.
    fn generate_side() -> String {
        let mut rng = rand::thread_rng();
        let mut buffer = [0u8; 8];
        rng.fill_bytes(&mut buffer);
        hex::encode(buffer)
    }
}

#[cfg(test)]
mod tests {
    // TODO: Tests for Client

    use super::{Client, PeerMessage};
    use std::collections::HashMap;

    #[test]
    fn side_id_generation() {
        let side = Client::generate_side();
        assert_eq!(side.len(), 16);
    }

    #[test]
    fn serialization() {
        let msg = PeerMessage::Version {
            abilities: None,
            app_versions: HashMap::new(),
        };
        let json = serde_json::to_string(&msg).unwrap();
        assert_eq!(json, "{\"app_versions\":{}}");
    }

    #[test]
    fn deserialisation() {
        let json = "{\"app_versions\":{}}";
        let msg = serde_json::from_str::<PeerMessage>(&json).unwrap();
        assert_eq!(
            msg,
            PeerMessage::Version {
                abilities: None,
                app_versions: HashMap::new(),
            }
        );
    }
}
